//? #version 430 core
#include "kernels.gl"

#ifndef POISSON
	const vec2 DiscSorted[g_kSizeDisc] = DiscVogelSorted;
#else
	const vec2 DiscSorted[g_kSizeDisc] = DiscPoissonSorted;
#endif

const int g_kNumCascades = 4;

// CSM
uniform float AVsFarCascade[g_kNumCascades];
uniform mat4 ReferenceShadowMatrix;
uniform vec3 AOffsetCascade[g_kNumCascades];
uniform vec3 AScaleCascade[g_kNumCascades];
// Shadow Bias
uniform float Bias;
uniform float ScaleNormalOffsetBias;
// Disc PCF
uniform float SizeFilter;
// PCSS
uniform float WidthLight;
uniform float RadRotationTemporal;

float PenumbraRadius(float depthReceiver, float depthBlocker, float widthLight) {
    return abs(widthLight * (depthReceiver - depthBlocker) / depthBlocker);
}

float SampleShadowMapRandomDiscPCFPCSS(vec3 uvz, uint idxCascade, vec3 wsPos, float widthLight,
	sampler2DArrayShadow ShadowMapArrayPCF, sampler2DArray ShadowMapArrayDepth, sampler2D Noise) {
	
	const vec2 sizeFilter = SizeFilter.xx * abs(AScaleCascade[idxCascade].xy);
	const vec2 sizeShadowMap = textureSize(ShadowMapArrayPCF, 0).xy;
    const float depth = clamp(uvz.z + Bias, 0, 1); // clamp to avoid buggy results at infinity
	
	const vec2 uvNoise = gl_FragCoord.xy / vec2(textureSize(Noise, 0).xy);
	const float radAngle = texture(Noise, uvNoise).x * 2 * 3.1415 + RadRotationTemporal;
	const mat2x2 randomRotationMatrix = mat2x2(vec2(cos(radAngle), -sin(radAngle)),
												vec2(sin(radAngle),  cos(radAngle)));
	const vec2 scaleSample = max(vec2(0), 0.5 * abs(sizeFilter) / sizeShadowMap);

	const uint kSizeDisc = 10;

	// blocker search
	float depthOccluderAverage = 0;
	int numOcluderSamples = 0;
	for (uint i = 0; i < kSizeDisc; ++i) {
		const vec2 offsetSample = (randomRotationMatrix * DiscSorted[i]) * scaleSample;
		const vec2 posSample = uvz.xy + offsetSample;
		const float depthSample = texture(ShadowMapArrayDepth, vec3(posSample, idxCascade)).r;
		if (depthSample > depth) {
			depthOccluderAverage += depthSample;
			++numOcluderSamples;
		}
	}

	// early stop
	if (numOcluderSamples == 0)
		return 1;
	else if (numOcluderSamples == kSizeDisc)
		return 0;

	// determine kernel scale for PCF
	depthOccluderAverage /= numOcluderSamples;
	const float penumbraRadius = PenumbraRadius(depth, depthOccluderAverage, widthLight);
	const float scale = clamp(penumbraRadius / kSizeDisc, 0.1, 1.0);

	// PCF
	float sum = 0.0f;
	for(int i = 0; i < kSizeDisc; ++i) {
		const vec2 offsetSample = (randomRotationMatrix * DiscSorted[i]) * scaleSample * scale;
		const vec2 posSample = uvz.xy + offsetSample;
		sum += texture(ShadowMapArrayPCF, vec4(posSample, idxCascade, depth));
    }
	return sum / kSizeDisc;
}

// functions with comments like below was rewritten to GLSL from https://github.com/TheRealMJP/Shadows/blob/master/Shadows/Mesh.hlsl

//-------------------------------------------------------------------------------------------------
// Samples the appropriate shadow map cascade
//-------------------------------------------------------------------------------------------------
float SampleShadowCascade(vec3 uvz, uint idxCascade, vec3 wsPos, float widthLight,
	sampler2DArrayShadow ShadowMapArrayPCF, sampler2DArray ShadowMapArrayDepth, sampler2D Noise) {

    uvz += AOffsetCascade[idxCascade].xyz;
    uvz *= AScaleCascade[idxCascade].xyz;

    //return SampleShadowMapFixedSizePCF(uvz, idxCascade, ShadowMapArrayPCF, Bias);
	return SampleShadowMapRandomDiscPCFPCSS(uvz, idxCascade, wsPos, widthLight,
		ShadowMapArrayPCF, ShadowMapArrayDepth, Noise);
}
//-------------------------------------------------------------------------------------------------
// Calculates the offset to use for sampling the shadow map, based on the surface normal
//-------------------------------------------------------------------------------------------------
vec3 GetWsShadowPosOffset(float nDotL, vec3 wsNormal, float sizeShadowMap) {
    const float sizeTexel = 2.0f / sizeShadowMap;
    const float nmlOffsetScale = 1.0f - nDotL;
    return sizeTexel * ScaleNormalOffsetBias * nmlOffsetScale * wsNormal;
}

float ShadowVisibility(vec3 wsPos, float vsDepth, float nDotL, vec3 wsNormal, float widthLight,
	sampler2DArrayShadow ShadowMapArrayPCF, sampler2DArray ShadowMapArrayDepth, sampler2D Noise) {
    
	const vec3 projectionShadowPos = (ReferenceShadowMatrix * vec4(wsPos, 1.0f)).xyz;
	
	int idxCascade = g_kNumCascades-1;
	// projection base cascade selection
	for(int i = g_kNumCascades - 1; i >= 0; --i) {
		// Select based on whether or not the pixel is inside the projection
		vec2 uv = projectionShadowPos.xy + AOffsetCascade[i].xy;
		uv *= AScaleCascade[i].xy;
		uv = abs(uv - 0.5f);
		if(uv.x <= 0.5f && uv.y <= 0.5f)
			idxCascade = i;
	}

    const vec3 wsPosOffset = GetWsShadowPosOffset(nDotL, wsNormal, textureSize(ShadowMapArrayPCF, 0).x);
	const vec3 uvz = (ReferenceShadowMatrix * vec4(wsPos + wsPosOffset, 1.0f)).xyz;
	float shadowVisibility = SampleShadowCascade(uvz, idxCascade, wsPos, widthLight, ShadowMapArrayPCF, ShadowMapArrayDepth, Noise);
	
	// Sample the next cascade, and blend between the two results to smooth the transition
	const float kBlendThreshold = 0.2f;

	const float vsNextSplit = AVsFarCascade[idxCascade];
	const float vsSizeSplit = idxCascade == 0 ? vsNextSplit : vsNextSplit - AVsFarCascade[idxCascade - 1];
	float fadeFactor = (vsNextSplit - vsDepth) / vsSizeSplit;
	
	vec3 posCascade = projectionShadowPos + AOffsetCascade[idxCascade].xyz;
	posCascade *= AScaleCascade[idxCascade].xyz;
	posCascade = abs(posCascade * 2.0f - 1.0f);
	const float distToEdge = 1.0f - max(max(posCascade.x, posCascade.y), posCascade.z);
	fadeFactor = max(distToEdge, fadeFactor);
	
	if(fadeFactor <= kBlendThreshold && idxCascade != (g_kNumCascades - 1)) {
		const float nextSplitShadowVisibility = SampleShadowCascade(uvz, idxCascade + 1, wsPos, widthLight, ShadowMapArrayPCF, ShadowMapArrayDepth, Noise);
		const float mixAmt = smoothstep(0.0f, kBlendThreshold, fadeFactor);
		shadowVisibility = mix(nextSplitShadowVisibility, shadowVisibility, mixAmt);
    }
	return shadowVisibility;
}